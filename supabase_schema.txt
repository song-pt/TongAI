
-- 1. 创建访问密钥表（存储账号）
create table if not exists access_keys (
  id uuid default gen_random_uuid() primary key,
  code text unique not null,
  note text,
  is_active boolean default true,
  created_at timestamptz default now(),
  total_tokens bigint default 0,
  token_limit bigint default null
);

-- 9. [NEW] 创建图像访问密钥表
create table if not exists image_access_keys (
  id uuid default gen_random_uuid() primary key,
  code text unique not null,
  note text,
  is_active boolean default true,
  created_at timestamptz default now(),
  total_images bigint default 0,
  image_limit bigint default null
);

-- 2. 创建设备会话表（存储设备记录）
create table if not exists device_sessions (
  id uuid default gen_random_uuid() primary key,
  key_code text references access_keys(code) on delete cascade,
  device_id text not null,
  last_seen timestamptz default now(),
  device_info text default 'Unknown',
  total_tokens bigint default 0,
  is_banned boolean default false,
  unique(key_code, device_id)
);

-- 安全地添加列：检查 image_key_code 是否存在，不存在则添加
do $$
begin
    if not exists (select 1 from information_schema.columns where table_name = 'device_sessions' and column_name = 'image_key_code') then
        alter table device_sessions add column image_key_code text references image_access_keys(code) on delete set null;
    end if;
end $$;

-- 3. 创建聊天历史表
create table if not exists chat_history (
  id uuid default gen_random_uuid() primary key,
  key_code text references access_keys(code) on delete cascade,
  question text not null,
  answer text not null,
  subject text default 'math',
  grade_label text,
  device_id text,
  created_at timestamptz default now()
);

-- 4. 创建系统配置表
create table if not exists app_config (
  key text primary key,
  value text not null
);

-- 插入默认配置 (包含 admin_password 和 ai_mode)
insert into app_config (key, value) values 
('app_title', 'TongAI'),
('admin_password', '114514'),
('ai_mode', 'solver')
on conflict (key) do nothing;

-- 开启 RLS 策略
alter table app_config enable row level security;

-- [FIX] 安全创建策略：先删除旧策略，再创建新策略，防止 Error 42710
drop policy if exists "Allow public read access" on app_config;
create policy "Allow public read access" on app_config for select using (true);

drop policy if exists "Allow all access for authenticated/service role" on app_config;
create policy "Allow all access for authenticated/service role" on app_config for all using (true) with check (true);

-- 5. 创建登录函数
create or replace function login_with_key(
  input_code text, 
  input_device_id text,
  input_user_agent text
)
returns boolean
language plpgsql
security definer
as $$
declare
  found_key text;
  device_is_banned boolean;
begin
  select code into found_key from access_keys where code = input_code and is_active = true;
  
  if found_key is null then
    return false;
  end if;

  select is_banned into device_is_banned from device_sessions where key_code = found_key and device_id = input_device_id;
  if device_is_banned is true then
    return false;
  end if;

  insert into device_sessions (key_code, device_id, last_seen, device_info, is_banned)
  values (found_key, input_device_id, now(), input_user_agent, false)
  on conflict (key_code, device_id) do update
  set last_seen = now(), device_info = input_user_agent;

  return true;
end;
$$;

-- 10. [NEW] 验证并绑定图像密钥函数 (嵌套逻辑)
create or replace function verify_image_key(
  input_image_code text,
  input_main_code text,
  input_device_id text
)
returns boolean
language plpgsql
security definer
as $$
declare
  found_img_key record;
begin
  -- 1. Check Image Key Exists and is Active
  select * into found_img_key from image_access_keys where code = input_image_code and is_active = true;
  
  if found_img_key is null then
    return false;
  end if;

  -- 2. Check Quota
  if found_img_key.image_limit is not null and found_img_key.total_images >= found_img_key.image_limit then
    return false;
  end if;

  -- 3. Update Session to Link Image Key with Main Key Session
  update device_sessions 
  set image_key_code = input_image_code
  where key_code = input_main_code and device_id = input_device_id;

  return true;
end;
$$;

-- 6. 创建计费与限额检查函数
create or replace function increment_token_usage(
  input_code text,
  input_device_id text,
  usage_amount int
)
returns void
language plpgsql
security definer
as $$
declare
  updated_total bigint;
  limit_val bigint;
  key_id uuid;
begin
  update access_keys 
  set total_tokens = total_tokens + usage_amount 
  where code = input_code
  returning id, total_tokens, token_limit into key_id, updated_total, limit_val;

  update device_sessions 
  set total_tokens = total_tokens + usage_amount 
  where key_code = input_code and device_id = input_device_id;

  if limit_val is not null and updated_total >= limit_val then
    update access_keys set is_active = false where id = key_id;
  end if;
end;
$$;

-- 11. [NEW] 增加图片使用计数函数
create or replace function increment_image_usage(
  input_image_code text
)
returns void
language plpgsql
security definer
as $$
declare
  updated_total bigint;
  limit_val bigint;
  key_id uuid;
begin
  update image_access_keys 
  set total_images = total_images + 1
  where code = input_image_code
  returning id, total_images, image_limit into key_id, updated_total, limit_val;

  if limit_val is not null and updated_total >= limit_val then
    update image_access_keys set is_active = false where id = key_id;
  end if;
end;
$$;

-- 7. 创建历史记录插入函数 (保留最新50条)
create or replace function add_chat_message(
  p_key_code text,
  p_question text,
  p_answer text,
  p_subject text,
  p_grade_label text,
  p_device_id text
)
returns void
language plpgsql
security definer
as $$
begin
  insert into chat_history (key_code, question, answer, subject, grade_label, device_id)
  values (p_key_code, p_question, p_answer, p_subject, p_grade_label, p_device_id);

  delete from chat_history
  where id in (
    select id from chat_history
    where key_code = p_key_code
    order by created_at desc
    offset 50
  );
end;
$$;

-- 8. [BUG FIX] 创建配置更新函数 (绕过RLS限制)
create or replace function update_config_value(key_name text, new_value text)
returns void
language plpgsql
security definer
as $$
begin
  insert into app_config (key, value) values (key_name, new_value)
  on conflict (key) do update set value = new_value;
end;
$$;
